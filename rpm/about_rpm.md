# 标签和名字
看起来很想，但是标签在文件内，名字只是它的名字。
所以一个包就算改了名字 还是会被识别出来

# rpm -i 会做什么
- 进行依赖检测
- 检测冲突
- 执行安装前任务
- 决定对冲突文件的操作
- 从包中解压文件，然后把他们放到合适的地方
- 执行安装后的操作
- 追踪做了什么

**你也可以通过一个URL来唯一的确定一个rpm包**

# rpm -e 会干什么
- 检测RPM数据库，确认不删除其他包的依赖
- 执行 pre-uninstall 脚本（如果有的话）
- 如果包的配置文件修改了，它会备份（不要太机智，看看人家）
- 从RPM数据库中查询所有属于这个包的文件，如果这些文件不属于其他包，就把这些文件删掉
- 执行 post-uninstall脚本（如果存在的话）
- 从数据库中删除关于这个包的所有痕迹(包括属于它的文件)

# rpm -u 会干什么
1. 安装所需的包
2. 卸载老版本的包

如果你觉得rpm -U只是相当于 rpm -i 和 rpm -e 的话，<br>
那么<br>
基本上你就答对了

但是不完全是这样，如果rpm使用了很“smart”的升级命令，同时install和erase命令不能完整掌控升级的情
况：
- 安装一个包可能会重写修改好的配置文件
- 擦除一个包可能意味着配置文件可能被移除

这样可能会有问题。<br>
但是你使用rpm的更新的话，就算你同事你有包的多个版本，也能处理的很好。

# rpm -u 中配置文件的魔法
实际上这里说的是 在rpm -u的时候 rpm如何处理配置文件的，我们有三种配置文件

- 老的包最初的配置文件（原始文件）
- 现在的配置文件（现有文件）
- 新的包最初的配置文件（新文件）

rpm使用MD5来计算出一个值，来判断这些文件是否有差别，所以有下面六中情况：

### 原始文件=X，现在的文件=X，新文件=X
这种情况，RPM会用新文件覆盖原始文件。<br>
这么做的原因是一个文件不仅仅只是文件名和内容（还设有用户权限等待）

### 原始文件=X，现在的文件=X，新文件=Y
覆盖配置文件，不保存现在的文件（因为它没有改动，你可以通过原来的包把它找回来）

### 原始文件=X，现在的文件=Y，新文件=X
不改动

### 原始文件=X，现在的文件=Y，新文件=Y
安装新的配置文件，原因和第一种情况相同

### 原始文件=X，现在的文件=Y，新文件=Z
安装新的配置文件，
